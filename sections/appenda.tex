%!TEX root = ../thesis.tex
\chapter{Computer Programs}
\label{appen:programs}
In this appendix some snippets of code we wrote during the course of this thesis are listed.
These snippets can be used to easily construct whole programs for finding zero divisors.

\section*{Finding Zero Divisors in C}
The following C functions attempt to find zero divisors of the form $1+a \mathbf{f}$ in the dihedral group ring $\mathbb{Z}_2 \mathbf{D}_{2k}$.
The dihedral group $\mathbf{D}_{2k}$ is generated by two generators, $a$ of order two and $b$ of order $k$.
The element $\mathbf{f}$ is a sum of powers of $b$.
The last $k$ bits of the sixty-four bit integer \emph{f} are the coefficients in $\mathbf{f}$ according to the listing of group elements $\{ ab^{k-1}, \ldots ,ab^2,ab,a \} $.

Two preliminary functions are needed here to facilitate the main snippets of code.
The first of these is called \emph{weight} which calculates the Hamming weight of a codeword and returns this as an integer.
The function code is not listed here, as the Hamming weight calculation we used is the standard one for calculating the weight of a sixty-four bit unsigned integer.
The second, also not listed but easily written, is called \emph{ith\_row} which returns the $i^{\textrm{th}}$ cycle of a codeword.
It requires two macros, \emph{K} and \emph{MASK}, to be defined.
The first is the dimension of the code we are looking for and the second is a bit mask for the last \emph{K} components of a sixty-four bit integer.
The function \emph{usq\_zero} then returns one if and only if $1 + a \mathbf{f}$ squared is zero.
It is listed in listing \ref{listing:cfindzds}.

\begin{listing}[ht]
\begin{minted}{c}
int usq_zero(unsigned long long f) {
  if ((weight(f) & 1) == 0)
  	return(0);

  for (int i = 1; i <= K/2; i++) 
    if (weight(f & ith_row(f, i)) & 1)
	  return 0;

  return 1;
}
\end{minted}
\caption{Test whether $(1 + a \mathbf{f})^2$ is zero.}
\label{listing:cfindzds}
\end{listing}


\section*{Minimum Distance Eight}
The previous code can easily be adapted to ensure that the code that is the principal left ideal of $u$ in the group ring is of minimum distance at least eight.
Here, as in the previous listing, we are using the techniques described in chapter \ref{chap:longer}.
Such an adaptation is given in listing \ref{listing:cmintdist8}.

\begin{listing}[ht]
\begin{minted}{c}
int min_dist_8(unsigned long long f) {
  if (weight(f) < 7)
    return 0;
  
  for (int i = 1; i <= K/2; i++) 
    if (weight(f ^ ith_row(f, i)) < 6)
	  return 0;

  return 1;
}
\end{minted}
\caption{Test whether the code has minimum distance eight or more.}
\label{listing:cmintdist8}
\end{listing}

\section*{General Groups}
The GAP code in listing \ref{listing:gapgmat} can be used to create the group matrix of any listing of a group.
The group listing is denoted by \emph{listing}.

\begin{listing}[ht]
\begin{minted}{gap}
ListingToGMat := function(listing)
  local ROW_LABS, i, G_MAT;
  ROW_LABS := List(listing, Inverse);

  G_MAT := [];
  for i in listing do
    Add(G_MAT, i*listing);
  od;

  return G_MAT;
end;;
\end{minted}		
\caption{Create the group matrix.}
\label{listing:gapgmat}
\end{listing}

This can be used along with the code in listing \ref{listing:gaprgmat} to create the group ring matrix of an element $u$.
Here \emph{u} is a list containing the coefficients of the elements in the group listing in order in $u$.
The variable \emph{gmat} is the group matrix according to the listing and can be the return value of the previous function \emph{ListingToGMat}.

\begin{listing}[ht]
\begin{minted}{gap}
VectorToRGMat := function(u, gmat)
  local RGMat, i, j, k, N;
  RGMat := [];
  N := Size(gmat[1]);
  for i in [1..N] do
    Add(RGMat, []);
    for j in [1..N] do
      for k in [1..N] do
        if (gmat[i][j] = gmat[1][k]) then
          Add(RGMat[i], u[k]);
        fi ;
      od ;
    od ;
  od;
  return RGMat;
end;;
\end{minted}
\caption{Create the group ring matrix.}
\label{listing:gaprgmat}
\end{listing}